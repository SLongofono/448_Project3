\documentclass{roffin}
\begin{document}

\title{Maintenance Plan: Spotify Recommendation Engine}

\author{Grant Jurgensen, Stephen Longofono, and Stephen Wiss}

\maketitle
This document serves to identify the ongoing process of maintaining our song recommendation software, strategies for doing so, and the associated costs. The maintenance of our software will likely boil down to updating and adding functionality based on changes to spotify's API. This involves a contingency plan in the case that Spotify begins charging for access to it's developer  accounts, and of course, adding refinement to our algorithm based off of functional differences in the API source code. 


\section{General Maintenance}


Speaking in terms of General ongoing Maintenance, Our update schedule would be synchronous to the Spotify web-api team's. That is to say That there wouldn't be a schedule. Judging by the graphed history of commits to the spotify web-api's github, It appears that updating and changes to the source code really only occur when there is something wrong with it. This means that if our team is to be effective at maintaining quality of life and smooth operation for our userbase, then we will have to be on top of and ready to integrate the changes to spotify's web-api to our source code. One thing worth noting however, is that our application utilizes Spotipy - an open-source python module incorporating the spotify API. This could prove to be either beneficial or costly to us. On one hand, we have a buffer between our source code and incompatible changes implemented into Spotify's API. On the other, we are dependent on the maintenance and upkeep of an open-source library that appears ( based once again on it's github commits ) to be dead. 

To combat these inevitable pitfalls, the most viable strategy would be to employ someone to act as a support representative/maintaining developer. The operative of this position would be two-fold:
    \begin{itemize}
        \item Address known issues. (changes to the API) 
        \item Provide support and feedback to user submitted bugs
    \end{itemize}


This is of course, a reactionary tactic. But the provided circumstances do not leave room for a lot of proactivity. However, if the project moves forward according to our Deployment Plan, more work will be required to maintain the additional features added to our application. 

It should also be mentioned that our application will need to be updated frequently to remain compatible with current working versions of popular operating systems. Some current features will add further complication to this and as such, We will have to consider switching out some aspects of our application for ones that are more scalable. 


\section{Potential Maintenance??}

In this section we'll cover a few hypotheticals that we touched on briefly in our introduction and have been mentioned in our deployment plan. 

In it's current state, our application is the opposite of user-friendly. This is fine at present, because our chief demographic are technically-minded users that wish to evolve and fit our source code and algorithm into more specific custom applications. In our deployment plan we mentioned that part of releasing our application will be to allow a user access to our algorithm in an effort to stream-line cross-implementation. This is great and fits perfectly with the open-source philosophy. However, in order to fund the upkeep and further development of our application it will be necessary to generate some revenue. This is discussed at length in our deployment plan. Maintenance for this portion of our release is relatively minor, We would need to have an active repository on github with perhaps a stickied thread on a technical/programming forum or board (ie. Reddit, stackexchange, etc...) with general tips and an FAQ.

The other phase of our release, which is the fully functioning song suggester application catering to less technically-conditioned users, will incur a significant amount of maintenance. First of all, The application in it's current state is a bit hard to use and involves running a shell-script to generate the users profile. As mentioned in our deployment plan we will have to port the application to IOS and Android. Doing so will alleviate the learning curve necessary to running our application. It will also incur more necessary maintenance. Which will be expanded upon in the next section. 

Our maintenance Plan would also be incomplete without discussing in detail what would happen should Spotify decide to start charging for access to it's web API. As is the case with all hypothetical situations, we can't be certain exactly what this would entail, but we can piece together some sort of contingency plan in the event that it happens.  
According to some research done, API pricing generally comes down to a tiered pricing list relative to depth of access or computational time. It's not for certain where our application would fall within this schema, but assuming the worst, this would add a large additional cost to maintaining our application. This would also incentivize us to revisit some portions of our application and make them more efficient in their use of API calls. 




\section{Maintenance Involving Services and Hosting}
Adapting and integrating our application to a fully-scaled and marketable product will introduce a lot of work in the deployment stage as mentioned before, but will generate numerous areas for maintenance as well. Our application as is, is written in python using the Spotipy module. Porting our application over to android would require rewriting the bulk of our code to Java, This would be feasible, taking into consideration the object oriented-ness of our algorithm, as well as the extent of libraries available on the java platform. In the case of making it available to apple users, the process becomes more involved. The portability of python to IOS is less accessible than for Android, and Apple tends to be pretty stringent in their approval process for applications that require network access to function. Also, We would need to wrap our application in Csharp or swift, and neither of these have included libraries for accessing the python web-API. The initial process of translating our application would require some work (a lot of work in the case of IOS), and maintaining it in it's translated state would require the same breed of maintenance already covered in the General Maintenance section. 

\subsection{Development Costs}
This is where subsection content goes

\subsection{Back End Costs}
This is where subsection content goes

\section{Conclusion}
This is where the conclusion goes

\vfill

\begin{thebibliography}{}

\bibitem[{Author(year)}]{myReferenceTag}
Lastname, F. (2016). \textit{Italic Article title}
Accessed November 29, 2016. \textit{Publication Name} http://www.urlofaccess.com/



\bibitem[{Author(year)}]{myReferenceTag2}
Lastname, F. (2016).
Title.
Journal Title, City, Country.


\end{thebibliography}


\end{document}
